10 13
BBBBBBBBWBWBW
BBBBBBBBBWBWB
BBBBBBBBWBWBW
BBBBBBBBBWBWB
BBBBBBBBWBWBW
BBBBBBBBBWBWB
BBBBBBBBWBWBW
BBBBBBBBBWBWB
WWWWWWWWWWBWB
WWWWWWWWWWBWB

-----

어떻게 풀어야 할까?
일단 2차원 배열로 받고 Black은 0, White는 1로 저장한다음에
다시 2중 for문 돌면서 인접한 면을 보면서 체스판으로서 만족하는지 마킹을 함
단순 마킹을 하지 말고, 마킹할 때 인접한 면의 정보를 이어받는거임
왼쪽 위에서부터 오른쪽 아래로 스캔한다 했을때 그 정보를 이어서..

------

새로 생각난 풀이 : 0,0 위치가 Black인 경우, White인 경우 두가지 경우로 나눠서 생각하기

1) 왼쪽위 코너가 흑 또는 백이라고 가정하고 나머지 전체 체스판에 대해서 바뀌어야 할 부분 마킹하기
2) 마킹한 배열을 돌면서 특정 위치가 8x8 체스판의 왼쪽위 코너라고 가정했을 때 몇개의 칸이 바뀌어야 하는지 합을 구해서 최소값 찾기

시간 단축 방법
전체 판에서 8x8 체스판을 돌며 변경될 칸의 합을 구할때 매번 8*8번 반복하지 말고 변경되는 부분만 가감하기
주로 횡이동하면서 스캔을 할 거라 세로로 8칸의 합을 하나의 배열에 저장, 해당 배열의 크기는 8
그리고 index는 8 모듈러 연산으로 결정 (그렇게 되면 가감되는 배열의 index가 같아짐)
아래로 움직일때에는 8번 반복에서 맨 위에 칸 값을 빼주고 맨 아래 칸 값을 더해줘서 업데이트 해주기

세부적인 flow

1) 전체 chess board 입력 받기
2) topLeftCornerIsBlack() : 왼쪽위 코너의 색이 검정이라고 가정하고 변경되어야 할 칸 flag 배열 만들기
2-1) countTotalChanges(blackFlagArray) : 2번에서 구한 리스트를 넘겨받아서 최소 변경 개수 구하기
3) topLeftCornerIsWhite() : 왼쪽위 코너의 색이 흰색이라고 가정하고 변경되어야 할 칸 flag 배열 만들기
3-1) countTotalChanges(whiteFlagArray) : 3번에서 구한 리스트를 넘겨받아서 최소 변경 개수 구하기
4) printMinimumRepaint : 2-1에서 구한 값과 3-1에서 구한 값 중 작은 값 출력


countTotalChanges 알고리즘 어떻게 구성할 것인가?


