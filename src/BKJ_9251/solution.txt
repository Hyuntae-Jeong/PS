처음 풀이
두 문자열의 길이를 앞에서부터 1씩 늘려가면서 각각 문자열의 마지막 문자가 포함되는 LCS를 찾아나감
이때, 마지막 문자와 동일한 문자열이 앞에서 발견되면 바로 선택해버리는데, 이게 잘못된 풀이였음
예를 들어,
VLSKD
VREGDFELK
에서 기존 풀이(startProcess_old())대로 라면 D를 선택해서 뒤에 LK가 선택되지 않음
그래서 LCS가 VD로 출력됨 (정답은 VLK)

정답 풀이
Knapsack 문제처럼 2차원 배열을 만들고 각 조합에서 선택의 최댓값을 누적하는 풀이
즉, 같은 문자 나왔다고 냉큼 선택해버리는 것이 아니라, 뒤에 또 똑같은 문자가 나오면 그거를 선택하는 방법도 고려하는 방식
자세한 풀이 방법은 사진으로 첨부..


이 문제 풀이에 대한 접근 방법과 잘못된 풀이
- 문자 길이를 하나씩 늘려가면서 접근하는 방식은 괜찮은 시도였음.. 대부분 반례를 커버했으나
- 처음 나온 같은 문자 뒤에 더 나은 선택지가 있는 경우는 커버하지 못함
- 즉 잘못된 풀이는 앞에서부터 동일한 문자가 있으면 무조건 LCS로 선택해버린다는 점이다